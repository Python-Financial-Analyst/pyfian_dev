pyfian.fixed_income.floating_rate_note
======================================

.. py:module:: pyfian.fixed_income.floating_rate_note

.. autoapi-nested-parse::

   floating_rate_note.py

   Module for fixed income floating rate note analytics, including FloatingRateNote class for payment flows,
   valuation, and yield calculations. Adapted from FixedRateBullet.



Attributes
----------

.. autoapisummary::

   pyfian.fixed_income.floating_rate_note.list_maturities_rates


Classes
-------

.. autoapisummary::

   pyfian.fixed_income.floating_rate_note.FloatingRateNote


Module Contents
---------------

.. py:class:: FloatingRateNote(issue_dt: Union[str, pandas.Timestamp], maturity: Union[str, pandas.Timestamp], ref_rate_curve: Optional[pyfian.yield_curves.base_curve.YieldCurveBase] = None, current_ref_rate: Optional[float] = None, quoted_margin: float = 0.0, cpn_freq: int = 1, notional: float = 100, settlement_convention_t_plus: int = 1, record_date_t_minus: int = 1, settlement_date: Optional[Union[str, pandas.Timestamp]] = None, yield_to_maturity: Optional[float] = None, price: Optional[float] = None, adjust_to_business_days: bool = False, day_count_convention: str | pyfian.utils.day_count.DayCountBase = 'actual/actual-Bond', following_coupons_day_count: str | pyfian.utils.day_count.DayCountBase = '30/360', yield_calculation_convention: str = 'BEY')

   Bases: :py:obj:`pyfian.fixed_income.base_fixed_income.BaseFixedIncomeInstrument`


   Helper class that provides a standard way to create an ABC using
   inheritance.


   .. py:attribute:: issue_dt
      :type:  pandas.Timestamp
      :value: None



   .. py:attribute:: maturity
      :type:  pandas.Timestamp
      :value: None



   .. py:attribute:: ref_rate_curve
      :value: None



   .. py:attribute:: current_ref_rate
      :value: None



   .. py:attribute:: quoted_margin
      :value: 0.0



   .. py:attribute:: cpn_freq
      :value: 1



   .. py:attribute:: notional
      :value: 100



   .. py:attribute:: settlement_convention_t_plus
      :value: 1



   .. py:attribute:: record_date_t_minus
      :value: 1



   .. py:attribute:: day_count_convention
      :type:  pyfian.utils.day_count.DayCountBase


   .. py:attribute:: adjust_to_business_days
      :type:  bool
      :value: False



   .. py:attribute:: following_coupons_day_count
      :type:  pyfian.utils.day_count.DayCountBase


   .. py:attribute:: yield_calculation_convention
      :type:  str


   .. py:attribute:: payment_flow
      :type:  dict[pandas.Timestamp, float]


   .. py:attribute:: coupon_flow
      :type:  dict[pandas.Timestamp, float]


   .. py:attribute:: spread_flow
      :type:  dict[pandas.Timestamp, float]


   .. py:attribute:: amortization_flow
      :type:  dict[pandas.Timestamp, float]


   .. py:attribute:: _settlement_date
      :type:  Optional[pandas.Timestamp]
      :value: None



   .. py:method:: _validate_yield_calculation_convention(yield_calculation_convention: str) -> str


   .. py:method:: _validate_following_coupons_day_count(following_coupons_day_count: str | pyfian.utils.day_count.DayCountBase) -> pyfian.utils.day_count.DayCountBase

      Validate the following coupons day count convention.
      Raises ValueError if the convention is not supported.



   .. py:method:: make_payment_flow() -> tuple[dict[pandas.Timestamp, float], dict[pandas.Timestamp, float], dict[pandas.Timestamp, float]]

      Generate the payment flow (cash flows) for the bond.
      Returns a tuple of dictionaries:

      * dict_payments: Payment dates as keys and cash flow amounts as values.
      * dict_spreads: Spread payment dates as keys and spread amounts as values.
      * dict_amortization: Amortization payment dates as keys and amortization amounts as values.

      :returns: * **dict_payments** (*dict*) -- Dictionary with payment dates as keys and cash flow amounts as values.
                * **dict_spreads** (*dict*) -- Dictionary with spread payment dates as keys and spread amounts as values.
                * **dict_amortization** (*dict*) -- Dictionary with amortization payment dates as keys and amortization amounts as values.

      :raises ValueError: If the bond is not properly initialized.

      .. rubric:: Examples

      >>> bond = FixedRateBullet('2020-01-01', '2025-01-01', 5, 1, notional=1000)
      >>> bond.make_payment_flow() # doctest: +SKIP
      {Timestamp('2025-01-01 00:00:00'): 1050.0, Timestamp('2024-01-01 00:00:00'): 50.0, ...}



   .. py:method:: _calculate_time_to_payments(settlement_date, price, adjust_to_business_days, following_coupons_day_count, yield_calculation_convention, day_count_convention, payment_flow: Optional[dict[pandas.Timestamp, float]] = None) -> dict[float, float]

      Calculate the time to each payment from the settlement date.



   .. py:method:: make_expected_coupon_flow(current_ref_rate: Optional[float] = None, ref_rate_curve: Optional[pyfian.yield_curves.base_curve.YieldCurveBase] = None, settlement_date: Optional[Union[str, pandas.Timestamp]] = None) -> dict[pandas.Timestamp, float]

      Generate the expected coupon payment flow (cash flows) for the bond from the settlement date onwards.
      Uses the reference rate curve to estimate future reference rates for coupon calculations.

      :param current_ref_rate: Current reference rate as a decimal. If not provided, will use self.current_ref_rate.
      :type current_ref_rate: float, optional
      :param ref_rate_curve: Reference rate curve to use for estimating future rates. If not provided, will use self.ref_rate_curve.
      :type ref_rate_curve: YieldCurveBase, optional
      :param settlement_date: Settlement date. Defaults to issue date.
      :type settlement_date: str or datetime-like, optional

      :returns: **expected_coupon_flow** -- Dictionary with coupon payment dates as keys and cash flow amounts as values.
      :rtype: dict

      .. rubric:: Examples

      >>> bond = FloatingRateNote('2020-01-01', '2025-01-01', ref_rate_curve, current_ref_rate=0.02, quoted_margin=50, cpn_freq=2)
      >>> bond.make_real_payment_flow(settlement_date='2022-01-01') # doctest: +SKIP
      {Timestamp('2022-07-01 00:00:00'): 1.25, Timestamp('2023-01-01 00:00:00'): 1.25, ...}



   .. py:method:: value_with_curve(curve: pyfian.yield_curves.base_curve.YieldCurveBase, spread: float = 0, settlement_date: Optional[Union[str, pandas.Timestamp]] = None, price: Optional[float] = None, adjust_to_business_days: Optional[bool] = None, day_count_convention: Optional[str | pyfian.utils.day_count.DayCountBase] = None, following_coupons_day_count: Optional[str | pyfian.utils.day_count.DayCountBase] = None, yield_calculation_convention: Optional[str] = None) -> tuple[float, dict[float, float]]

      Value the bond using a discount curve.

      Calculates the present value of the bond's cash flows using the provided discount curve.

      Returns the total present value and a dictionary of present values for each payment.

      If a bond price is provided, it is included as a negative cash flow, and the
      present value would be equivalent to a Net Present Value (NPV) calculation, useful for
      comparing the bond's market price against its theoretical value based on the discount curve.

      The curve should have a method `discount_date(d)` that returns the discount factor for a given date `d`.

      The discount factor is typically calculated as:

      .. math::
          discount_date(d) = \frac{1}{(1 + r(d))^t}

      where:

      - :math:`r(d)` is the discount rate at date :math:`d`.
      - :math:`t` is the time in years from the settlement date to date :math:`d`.

      The discount factor brings the future value back to the present. Using this discount factor, we can calculate the present value of future cash flows by discounting them back to the settlement date.

      For a set of cash flows :math:`C(t)` at times :math:`t`, the present value (PV) is calculated as:

      .. math::
          PV = \sum_{i}^{N} C(d_i) * discount_date(d_i)

      for each (:math:`d_i`, :math:`C(d_i)`) cash flow, where :math:`i = 1, ..., N`

      where:

      - :math:`PV` is the present value of the cash flows
      - :math:`C(d)` is the cash flow at date :math:`d`
      - :math:`N` is the total number of cash flows
      - :math:`r(d)` is the discount rate at date :math:`d`.

      The discount rate for a cash flow at date :math:`d` is obtained from the discount curve using `curve.discount_date(d)`.

      This can be used to optimize the yield curve fitting process.

      :param curve: Discount curve object with a discount_date(d) method.
      :type curve: object
      :param settlement_date: Settlement date. Defaults to issue date.
      :type settlement_date: str or datetime-like, optional
      :param price: If provided, includes bond price as a negative cash flow.
      :type price: float, optional
      :param adjust_to_business_days: Whether to adjust payment dates to business days. Defaults to value of self.adjust_to_business_days.
      :type adjust_to_business_days: bool, optional
      :param day_count_convention: Day count convention. Defaults to value of self.day_count_convention.
      :type day_count_convention: str or DayCountBase, optional
      :param following_coupons_day_count: Day count convention for following coupons. Defaults to value of self.following_coupons_day_count.
      :type following_coupons_day_count: str or DayCountBase, optional
      :param yield_calculation_convention: Yield calculation convention. Defaults to value of self.yield_calculation_convention.
      :type yield_calculation_convention: str, optional

      :returns: * **total_value** (*float*) -- Present value of the bond.
                * **pv** (*dict*) -- Dictionary of present values for each payment.

      .. rubric:: Examples

      >>> from pyfian.yield_curves.flat_curve import FlatCurveBEY
      >>> bond = FixedRateBullet('2020-01-01', '2025-01-01', 5, 1)
      >>> bond.value_with_curve(FlatCurveBEY(curve_date="2020-01-01", bey=0.05)) # doctest: +SKIP
      (value, {t1: pv1, t2: pv2, ...})



   .. py:method:: yield_to_maturity(price: float, settlement_date: Optional[Union[str, pandas.Timestamp]] = None, adjust_to_business_days: Optional[bool] = None, day_count_convention: Optional[str | pyfian.utils.day_count.DayCountBase] = None, following_coupons_day_count: Optional[str | pyfian.utils.day_count.DayCountBase] = None, yield_calculation_convention: Optional[str] = None, current_ref_rate: Optional[float] = None, ref_rate_curve: Optional[pyfian.yield_curves.base_curve.YieldCurveBase] = None, tol: Optional[float] = 1e-06, max_iter: Optional[int] = 100) -> float

      Estimate the yield to maturity (YTM) using the xirr function from pyfian.time_value.irr.

      The YTM is the internal rate of return (IRR) of the bond's cash flows, assuming the bond is held to maturity.

      It is the discount rate that makes the present value of the bond's cash flows equal to its price for a given set of cash flows and settlement date.

      The YTM is calculated by solving the equation:

      .. math::
          P = \sum_{t=1}^{T} \frac{C_t}{(1 + YTM)^{(t+1)}}

      where:

      - :math:`P` is the price of the bond
      - :math:`C_t` is the cash flow at time :math:`t`, where :math:`t` is the time in years from the settlement date
      - :math:`YTM` is the yield to maturity
      - :math:`T` is the total number of periods

      The times to payments are calculated from the settlement date to each payment date and need not be integer values.

      :param price: Price of the bond.
      :type price: float
      :param settlement_date: Settlement date. Defaults to issue date.
      :type settlement_date: str or datetime-like, optional
      :param adjust_to_business_days: Whether to adjust payment dates to business days. Defaults to value of self.adjust_to_business_days.
      :type adjust_to_business_days: bool, optional
      :param day_count_convention: Day count convention. Defaults to value of self.day_count_convention.
      :type day_count_convention: str or DayCountBase, optional
      :param following_coupons_day_count: Day count convention for following coupons. Defaults to value of self.following_coupons_day_count.
      :type following_coupons_day_count: str or DayCountBase, optional
      :param yield_calculation_convention: Yield calculation convention. Defaults to value of self.yield_calculation_convention.
      :type yield_calculation_convention: str, optional
      :param tol: Tolerance for convergence (default is 1e-6).
      :type tol: float, optional
      :param max_iter: Maximum number of iterations (default is 100).
      :type max_iter: int, optional

      :returns: **ytm** -- Estimated yield to maturity as a decimal.
      :rtype: float

      :raises ValueError: If bond price is not set or YTM calculation does not converge.

      .. rubric:: Examples

      >>> bond = FloatingRateNote('2020-01-01', '2025-01-01', 5, 1)
      >>> bond.yield_to_maturity(price=95)
      np.float64(0.06100197251858131)



   .. py:method:: modified_duration(yield_to_maturity: Optional[float] = None, price: Optional[float] = None, settlement_date: Optional[Union[str, pandas.Timestamp]] = None, adjust_to_business_days: Optional[bool] = None, day_count_convention: Optional[str | pyfian.utils.day_count.DayCountBase] = None, following_coupons_day_count: Optional[str | pyfian.utils.day_count.DayCountBase] = None, yield_calculation_convention: Optional[str] = None) -> float

      Calculate modified duration of the bond.

      .. math::
          Modified Duration = \frac{1}{P} \sum_{t=1}^{T} \frac{C_t}{(1 + YTM)^{(t+1)}} \cdot t
      where:

      - :math:`P` is the price of the bond
      - :math:`C_t` is the cash flow at time :math:`t`, where :math:`t` is the time in years from the settlement date
      - :math:`YTM` is the yield to maturity
      - :math:`T` is the total number of periods

      The times to payments are calculated from the settlement date to each payment date and need not be integer values.

      :param yield_to_maturity: Yield to maturity as a decimal. If not provided, will be calculated from price if given.
      :type yield_to_maturity: float, optional
      :param price: Price of the bond. Used to estimate YTM if yield_to_maturity is not provided.
      :type price: float, optional
      :param settlement_date: Settlement date. Defaults to issue date.
      :type settlement_date: str or datetime-like, optional
      :param adjust_to_business_days: Whether to adjust payment dates to business days. Defaults to value of self.adjust_to_business_days.
      :type adjust_to_business_days: bool, optional
      :param day_count_convention: Day count convention. Defaults to value of self.day_count_convention.
      :type day_count_convention: str or DayCountBase, optional
      :param following_coupons_day_count: Day count convention for following coupons. Defaults to value of self.following_coupons_day_count.
      :type following_coupons_day_count: str or DayCountBase, optional
      :param yield_calculation_convention: Yield calculation convention. Defaults to value of self.yield_calculation_convention.
      :type yield_calculation_convention: str, optional

      :returns: **duration** -- Modified duration in years.
      :rtype: float

      .. rubric:: Examples

      >>> bond = FixedRateBullet('2020-01-01', '2025-01-01', 5, 2)
      >>> bond.effective_duration(yield_to_maturity=0.05, settlement_date='2020-01-01')
      4.3760319684



   .. py:method:: macaulay_duration(yield_to_maturity: Optional[float] = None, price: Optional[float] = None, settlement_date: Optional[Union[str, pandas.Timestamp]] = None, adjust_to_business_days: Optional[bool] = None, day_count_convention: Optional[str | pyfian.utils.day_count.DayCountBase] = None, following_coupons_day_count: Optional[str | pyfian.utils.day_count.DayCountBase] = None, yield_calculation_convention: Optional[str] = None) -> float

      Calculate macaulay duration of the bond.


      .. math::
          Macaulay Duration = \frac{1}{P} \sum_{t=1}^{T} \frac{C_t}{(1 + YTM)^{(t)}} \cdot t
      where:

      - :math:`P` is the price of the bond
      - :math:`C_t` is the cash flow at time :math:`t`, where :math:`t` is the time in years from the settlement date
      - :math:`YTM` is the yield to maturity
      - :math:`T` is the total number of periods

      The times to payments are calculated from the settlement date to each payment date and need not be integer values.

      :param yield_to_maturity: Yield to maturity as a decimal. If not provided, will be calculated from price if given.
      :type yield_to_maturity: float, optional
      :param price: Price of the bond. Used to estimate YTM if yield_to_maturity is not provided.
      :type price: float, optional
      :param settlement_date: Settlement date. Defaults to issue date.
      :type settlement_date: str or datetime-like, optional
      :param adjust_to_business_days: Whether to adjust payment dates to business days. Defaults to value of self.adjust_to_business_days.
      :type adjust_to_business_days: bool, optional
      :param day_count_convention: Day count convention. Defaults to value of self.day_count_convention.
      :type day_count_convention: str or DayCountBase, optional
      :param following_coupons_day_count: Day count convention for following coupons. Defaults to value of self.following_coupons_day_count.
      :type following_coupons_day_count: str or DayCountBase, optional
      :param yield_calculation_convention: Yield calculation convention. Defaults to value of self.yield_calculation_convention.
      :type yield_calculation_convention: str, optional

      :returns: **duration** -- Macaulay duration in years.
      :rtype: float

      .. rubric:: Examples

      >>> bond = FixedRateBullet('2020-01-01', '2025-01-01', 5, 2)
      >>> bond.macaulay_duration(yield_to_maturity=0.05)
      4.4854327646



   .. py:method:: convexity(yield_to_maturity: Optional[float] = None, price: Optional[float] = None, settlement_date: Optional[Union[str, pandas.Timestamp]] = None, adjust_to_business_days: Optional[bool] = None, day_count_convention: Optional[str | pyfian.utils.day_count.DayCountBase] = None, following_coupons_day_count: Optional[str | pyfian.utils.day_count.DayCountBase] = None, yield_calculation_convention: Optional[str] = None) -> float

      Calculate the convexity of the bond.



      .. math::
          Convexity = \frac{1}{P} \sum_{t=1}^{T} \frac{C_t \cdot t \cdot (t + 1)}{(1 + YTM)^{(t + 2)}}
      where:

      - :math:`P` is the price of the bond
      - :math:`C_t` is the cash flow at time :math:`t`, where :math:`t` is the time in years from the settlement date
      - :math:`YTM` is the yield to maturity
      - :math:`T` is the total number of periods

      The times to payments are calculated from the settlement date to each payment date and need not be integer values.

      :param yield_to_maturity: Yield to maturity as a decimal. If not provided, will be calculated from price if given.
      :type yield_to_maturity: float, optional
      :param price: Price of the bond. Used to estimate YTM if yield_to_maturity is not provided.
      :type price: float, optional
      :param settlement_date: Settlement date. Defaults to issue date.
      :type settlement_date: str or datetime-like, optional
      :param adjust_to_business_days: Whether to adjust payment dates to business days. Defaults to value of self.adjust_to_business_days.
      :type adjust_to_business_days: bool, optional
      :param day_count_convention: Day count convention. Defaults to value of self.day_count_convention.
      :type day_count_convention: str or DayCountBase, optional
      :param following_coupons_day_count: Day count convention for following coupons. Defaults to value of self.following_coupons_day_count.
      :type following_coupons_day_count: str or DayCountBase, optional
      :param yield_calculation_convention: Yield calculation convention. Defaults to value of self.yield_calculation_convention.
      :type yield_calculation_convention: str, optional

      :returns: **convexity** -- Bond convexity.
      :rtype: float

      .. rubric:: Examples

      >>> bond = FixedRateBullet('2020-01-01', '2025-01-01', 5, 2)
      >>> bond.convexity(yield_to_maturity=0.05)
      22.6123221851



   .. py:method:: accrued_interest(settlement_date: Optional[Union[str, pandas.Timestamp]] = None) -> float

      Calculate accrued interest since last coupon payment.
      This is the interest that has accumulated on the bond since the last coupon payment date
      or issue date if no coupon payments have been made.

      The accrued interest is calculated on an actual/actual basis, which means it considers
      the actual number of days between the last coupon payment date and the settlement date.

      The formula is as follows:

      .. math::
          Accrued = C \cdot \frac{SettlementDate - CouponDate_{prev}}{CouponDate_{next} - CouponDate_{prev}}

      where:

      - :math:`C` is the coupon payment amount
      - :math:`SettlementDate` is the date for which to calculate accrued interest
      - :math:`CouponDate_{prev}` is the last coupon payment date before the settlement or issue date if no previous coupon
      - :math:`CouponDate_{next}` is the next coupon payment date after the settlement

      :param settlement_date: Date for which to calculate accrued interest. Defaults to today.
      :type settlement_date: str or datetime-like, optional

      :returns: **accrued** -- Accrued interest amount.
      :rtype: float

      .. rubric:: Examples

      >>> bond = FixedRateBullet('2020-01-01', '2025-01-01', 5, 1)
      >>> bond.accrued_interest('2024-07-02')
      2.5



   .. py:method:: next_coupon_date(settlement_date: Optional[Union[str, pandas.Timestamp]] = None) -> Optional[pandas.Timestamp]

      Get the next coupon payment date from a given date.

      This method finds the next coupon payment date after the specified settlement date.
      If no future coupon payments exist, it returns None.

      :param settlement_date: Date from which to search. Defaults to today. Adjusts to settlement date.
      :type settlement_date: str or datetime-like, optional

      :returns: **next_date** -- Next coupon payment date, or None if none remain.
      :rtype: pd.Timestamp or None

      .. rubric:: Examples

      >>> bond = FixedRateBullet('2020-01-01', '2025-01-01', 5, 1)
      >>> bond.next_coupon_date('2023-06-01')
      Timestamp('2024-01-01 00:00:00')



   .. py:method:: previous_coupon_date(settlement_date: Optional[Union[str, pandas.Timestamp]] = None) -> Optional[pandas.Timestamp]

      Get the previous coupon payment date from a given date.

      This method finds the last coupon payment date before the specified settlement date.
      If no past coupon payments exist, it returns None.

      :param settlement_date: Date from which to search. Defaults to today. Adjusts to settlement date.
      :type settlement_date: str or datetime-like, optional

      :returns: **prev_date** -- Previous coupon payment date, or None if none exist.
      :rtype: pd.Timestamp or None

      .. rubric:: Examples

      >>> bond = FixedRateBullet('2020-01-01', '2025-01-01', 5, 1)
      >>> bond.previous_coupon_date('2023-06-01')
      Timestamp('2023-01-01 00:00:00')



   .. py:method:: __repr__() -> str

      Return string representation of the FixedRateBullet object.

      :returns: String representation of the bond.
      :rtype: str

      .. rubric:: Examples

      >>> bond = FloatingRateNote('2020-01-01', '2025-01-01', 100, 2)
      >>> print(bond)
      FloatingRateNote(issue_dt=2020-01-01 00:00:00, maturity=2025-01-01 00:00:00, quoted_margin=100, cpn_freq=2)



   .. py:method:: _price_from_yield(time_to_payments: dict[float, float], yield_to_maturity: float, yield_calculation_convention: str) -> float

      Helper to calculate the price of the bond from yield to maturity and time to payments.
      :param time_to_payments: Dictionary with time to payment (in years) as keys and cash flow values.
      :type time_to_payments: dict
      :param yield_to_maturity: Yield to maturity as a decimal (e.g., 0.05 for 5%).
      :type yield_to_maturity: float
      :param yield_calculation_convention: Yield calculation convention. Defaults to value of self.yield_calculation_convention.
      :type yield_calculation_convention: str

      :returns: Price of the bond.
      :rtype: float



   .. py:method:: _price_from_yield_and_clean_parameters(yield_to_maturity: float, settlement_date: Optional[Union[str, pandas.Timestamp]], adjust_to_business_days: bool, following_coupons_day_count: pyfian.utils.day_count.DayCountBase, yield_calculation_convention: str, day_count_convention: pyfian.utils.day_count.DayCountBase) -> float


.. py:data:: list_maturities_rates

